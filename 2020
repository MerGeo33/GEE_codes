/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var sen2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///// Add Cabo Delgado province as ROI
var ROI_feat = ee.FeatureCollection("FAO/GAUL/2015/level2")
  .filter(ee.Filter.eq('ADM1_NAME', 'Cabo Delgado'));

var ROI = ROI_feat.geometry();

Map.addLayer(ROI, {}, 'ROI',false);
Map.centerObject(ROI, 7);

///// visualisation param for Land-Cover Classes
var viz = {min:1,max:6,palette:['FF00C5','38A800','A5F57A','FF0000','00A9E6','FFEBBE']};
var palette = ['#d73027','#f46d43','#fdae61','#fee08b','#ffffbf','#d9ef8b','#a6d96a','#66bd63','#1a9850'];
var ndviVis = {min:-0.2, max: 0.8,  palette: palette};

////////////////////// Filtering and Masking Imagery ////////////////////////////////
/**
* Functions to mask clouds using the Sentinel-2 QA and SCL band
* @param {ee.Image} image Sentinel-2 image
* @return {ee.Image} cloud masked Sentinel-2 image
*/
function maskS2clouds(image) {
  var qa = image.select('QA60');

  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
      .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  return image.updateMask(mask).divide(10000)
    .copyProperties(image).set("system:time_start", image.get("system:time_start"));;
}

function maskS2scl(image) {
  // Select scene classification
  var scl = image.select('SCL');
  var sat = scl.neq(1);
  var shadow = scl.neq(3);
  var cloud_lo = scl.neq(7);
  var cloud_md = scl.neq(8);
  var cloud_hi = scl.neq(9);
  var cirrus = scl.neq(10);
  var snow = scl.neq(11);
  
  return image.updateMask(sat.eq(1)).updateMask(shadow.eq(1).updateMask(cloud_lo.eq(1)
    .updateMask(cloud_md.eq(1).updateMask(cloud_hi.eq(1).updateMask(cirrus.eq(1).updateMask(snow.eq(1)))))));
}

///// Function to compute spectral indices and add as bands
var compute_indices = function(image) {
  var ndvi = image.normalizedDifference(['B8','B4'])
    .rename('NDVI');
  var evi = image.expression(
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('B8'),
      'RED': image.select('B4'),
      'BLUE': image.select('B2')})
      .rename('EVI');
  var ndmi = image.normalizedDifference(['B8', 'B11'])
    .rename('NDMI');
  var savi = image.expression('((nir-red)/(nir+red+0.5))*(1+0.5)', {
    'nir': image.select('B8'),
    'red': image.select('B4')})
    .rename('SAVI');
  var gcvi = image.expression('(nir/green)-1', {
    'nir': image.select('B8'),
    'green': image.select('B3')})
    .rename('GCVI');
  var bi = image.expression('((red+swir1)-(nir+blue))/((red+swir1)+(nir+blue))', {
    'swir1': image.select('B11'),
    'nir': image.select('B8'),
    'red': image.select('B4'),
    'blue': image.select('B2')})
    .rename('BI');
  return image.addBands(ndvi).addBands(evi).addBands(ndmi).addBands(savi).addBands(gcvi).addBands(bi);
};

//////// Filter Sentinel-2 images by date, ROI and Cloudy Pixel Percentage
//////// apply cloud masking and compute indices

var sen2_2020 = sen2.filterDate('2019-11-01','2020-10-31')
  .filterBounds(ROI)
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30))
  .map(maskS2clouds)
  .map(maskS2scl)
  .select('B2','B3','B4','B8','B11')
  .map(compute_indices);
// print(sen2_2020);

// Map.addLayer(sen2_2020.select('NDVI'), ndviVis, 'Sen2 2020 NDVI mosaic',false);

//////// Smooth time-series and gap-filling with 12-days moving-window /////////

///// Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: sen2_2020.select('NDVI'),
//   region: cropland,
//   reducer: ee.Reducer.mean()
// }).setOptions({
//       title: 'Original NDVI Time Series',
//       interpolateNulls: false,
//       vAxis: {title: 'NDVI'},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#238b45'},
//       },

//     })
// print(chart);

///// Moving-Window Smoothing
// Specify the time-window
var days = 12;

// Convert to milliseconds 
var millis = ee.Number(days).multiply(1000*60*60*24);

// 'save-all join' to find all images within the time-window
// The join will add all matching images into a new property called 'images'
var join = ee.Join.saveAll({
  matchesKey: 'images'
});

// This filter will match all images that are captured
// within the specified day of the source image
var diffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start', 
  rightField: 'system:time_start'
});

var joinedCollection = join.apply({
  primary: sen2_2020, 
  secondary: sen2_2020, 
  condition: diffFilter
});

// Extract and return the mean of matched images
var extractAndComputeMean = function(image) {
  var matchingImages = ee.ImageCollection.fromImages(image.get('images'));
  var meanImage = matchingImages.reduce(
    ee.Reducer.mean().setOutputs(['smooth']));
  return ee.Image(image).addBands(meanImage);
};

var smoothedCollection = ee.ImageCollection(
  joinedCollection.map(extractAndComputeMean));

// Map.addLayer(smoothedCollection.select('NDVI_smooth'), ndviVis, 'Sen2 2020 NDVI smoothed mosaic',false);

///// Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: smoothedCollection.select(['NDVI','NDVI_smooth']),
//   region: cropland,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       title: 'NDVI Time Series',
//       interpolateNulls: false,
//       vAxis: {title: 'NDVI'},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#66c2a4', lineDashStyle: [1, 1], pointSize: 2}, // Original NDVI
//         1: {color: '#238b45', lineWidth: 2 }, // Smoothed NDVI
//       },

//     })
// print(chart);

/////////// seasonal filter of smoothed collection /////////////////
var s2_2020_wet = smoothedCollection.filterDate('2019-11-01','2020-05-31');
var s2_2020_dry = smoothedCollection.filterDate('2020-06-01','2020-10-31');

///// Calculate P25, P50, P75, P95 Percentiles per seasons
var s2_20_wet_perc = s2_2020_wet.reduce(ee.Reducer.percentile([25,50,75,95]));
var s2_20_dry_perc = s2_2020_dry.reduce(ee.Reducer.percentile([25,50,75,95]));

///// Rename bands
var s2_20_wet_perc = s2_20_wet_perc.select('B2_smooth_p25','B2_smooth_p50','B2_smooth_p75','B2_smooth_p95',
  'B3_smooth_p25','B3_smooth_p50','B3_smooth_p75','B3_smooth_p95',
  'B4_smooth_p25','B4_smooth_p50','B4_smooth_p75','B4_smooth_p95',
  'B8_smooth_p25','B8_smooth_p50','B8_smooth_p75','B8_smooth_p95',
  'B11_smooth_p25','B11_smooth_p50','B11_smooth_p75','B11_smooth_p95',
  'NDVI_smooth_p25','NDVI_smooth_p50','NDVI_smooth_p75','NDVI_smooth_p95',
  'EVI_smooth_p25','EVI_smooth_p50','EVI_smooth_p75','EVI_smooth_p95',
  'NDMI_smooth_p25','NDMI_smooth_p50','NDMI_smooth_p75','NDMI_smooth_p95',
  'SAVI_smooth_p25','SAVI_smooth_p50','SAVI_smooth_p75','SAVI_smooth_p95',
  'GCVI_smooth_p25','GCVI_smooth_p50','GCVI_smooth_p75','GCVI_smooth_p95',
  'BI_smooth_p25','BI_smooth_p50','BI_smooth_p75','BI_smooth_p95')
  .rename('B2_p25','B2_p50','B2_p75','B2_p95',
  'B3_p25','B3_p50','B3_p75','B3_p95',
  'B4_p25','B4_p50','B4_p75','B4_p95',
  'B8_p25','B8_p50','B8_p75','B8_p95',
  'B11_p25','B11_p50','B11_p75','B11_p95',
  'NDVI_p25','NDVI_p50','NDVI_p75','NDVI_p95',
  'EVI_p25','EVI_p50','EVI_p75','EVI_p95',
  'NDMI_p25','NDMI_p50','NDMI_p75','NDMI_p95',
  'SAVI_p25','SAVI_p50','SAVI_p75','SAVI_p95',
  'GCVI_p25','GCVI_p50','GCVI_p75','GCVI_p95',
  'BI_p25','BI_p50','BI_p75','BI_p95');
var s2_20_dry_perc = s2_20_dry_perc.select('B2_smooth_p25','B2_smooth_p50','B2_smooth_p75','B2_smooth_p95',
  'B3_smooth_p25','B3_smooth_p50','B3_smooth_p75','B3_smooth_p95',
  'B4_smooth_p25','B4_smooth_p50','B4_smooth_p75','B4_smooth_p95',
  'B8_smooth_p25','B8_smooth_p50','B8_smooth_p75','B8_smooth_p95',
  'B11_smooth_p25','B11_smooth_p50','B11_smooth_p75','B11_smooth_p95',
  'NDVI_smooth_p25','NDVI_smooth_p50','NDVI_smooth_p75','NDVI_smooth_p95',
  'EVI_smooth_p25','EVI_smooth_p50','EVI_smooth_p75','EVI_smooth_p95',
  'NDMI_smooth_p25','NDMI_smooth_p50','NDMI_smooth_p75','NDMI_smooth_p95',
  'SAVI_smooth_p25','SAVI_smooth_p50','SAVI_smooth_p75','SAVI_smooth_p95',
  'GCVI_smooth_p25','GCVI_smooth_p50','GCVI_smooth_p75','GCVI_smooth_p95',
  'BI_smooth_p25','BI_smooth_p50','BI_smooth_p75','BI_smooth_p95')
  .rename('B2_dry_p25','B2_dry_p50','B2_dry_p75','B2_dry_p95',
  'B3_dry_p25','B3_dry_p50','B3_dry_p75','B3_dry_p95',
  'B4_dry_p25','B4_dry_p50','B4_dry_p75','B4_dry_p95',
  'B8_dry_p25','B8_dry_p50','B8_dry_p75','B8_dry_p95',
  'B11_dry_p25','B11_dry_p50','B11_dry_p75','B11_dry_p95',
  'NDVI_dry_p25','NDVI_dry_p50','NDVI_dry_p75','NDVI_dry_p95',
  'EVI_dry_p25','EVI_dry_p50','EVI_dry_p75','EVI_dry_p95',
  'NDMI_dry_p25','NDMI_dry_p50','NDMI_dry_p75','NDMI_dry_p95',
  'SAVI_dry_p25','SAVI_dry_p50','SAVI_dry_p75','SAVI_dry_p95',
  'GCVI_dry_p25','GCVI_dry_p50','GCVI_dry_p75','GCVI_dry_p95',
  'BI_dry_p25','BI_dry_p50','BI_dry_p75','BI_dry_p95');
// print(s2_20_wet_perc);
// print(s2_20_dry_perc);

///// Adding texture indices for the wet season
var texture = function(image) {
  var ndvi = image.select('NDVI_p50').multiply(10000).toUint16();
  var glcm3 = ndvi.glcmTexture({size: 3});
  var glcm10 = ndvi.glcmTexture({size: 10});
  var glcm20 = ndvi.glcmTexture({size: 20});
  var contrast3 = glcm3.select('NDVI_p50_contrast').rename('NDVI_contrast3');
  var contrast10 = glcm10.select('NDVI_p50_contrast').rename('NDVI_contrast10');
  var contrast20 = glcm20.select('NDVI_p50_contrast').rename('NDVI_contrast20');
  var savg3 = glcm3.select('NDVI_p50_savg').rename('NDVI_savg3');
  var savg10 = glcm10.select('NDVI_p50_savg').rename('NDVI_savg10');
  var savg20 = glcm20.select('NDVI_p50_savg').rename('NDVI_savg20');
  var diss3 = glcm3.select('NDVI_p50_diss').rename('NDVI_diss3');
  var diss10 = glcm10.select('NDVI_p50_diss').rename('NDVI_diss10');
  var diss20 = glcm20.select('NDVI_p50_diss').rename('NDVI_diss20');
  return image.addBands(contrast3).addBands(contrast10).addBands(contrast20)
              .addBands(savg3).addBands(savg10).addBands(savg20)
              .addBands(diss3).addBands(diss10).addBands(diss20);
};

var s2_20_wet_perc_tex = texture(s2_20_wet_perc);
// print(s2_20_wet_perc_tex);

///// Adding slope, elevation, long/lat and settlements
var DEM = ee.Image("NASA/NASADEM_HGT/001");
var slope = ee.Terrain.slope(DEM);
var lonlat = ee.Image.pixelLonLat();
var settlements = ee.Image("DLR/WSF/WSF2015/v1").unmask();

///// Stacking seasonal images to annual image with all bands
var s2_20_all = s2_20_dry_perc.addBands(DEM.select('elevation')).addBands(slope)
                              .addBands(lonlat)
                              .addBands(settlements)
                              .addBands(s2_20_wet_perc_tex);
print(s2_20_all);

// Map.addLayer(s2_20_all, {bands: ['B4_p50','B3_p50','B2_p50'], min: 0, max: 0.2}, 'Sen2 2020 wet season composite',false);
// Map.addLayer(s2_20_all, {bands: ['B4_dry_p50','B3_dry_p50','B2_dry_p50'], min: 0, max: 0.2}, 'Sen2 2020 dry season composite',false);

///////////////// Generating stratified sampled training points ////////////////////
//// loading trainingbase, prepared in ArcGIS Pro, adjust path ////
var trainingbase = ee.Image('projects/ee-mepo/assets/Trainingsbase_Raster');
// Map.addLayer(trainingbase,viz, 'TrainingBase', false);

// var points = function(image) {
//     var samples = image.stratifiedSample({
//     numPoints: 1000,
//     classBand: 'b1',
//     scale: 10,
//     geometries: true
//     });
//     return samples;
//     };
// Export.table.toAsset({
//   collection: ee.FeatureCollection(points(trainingbase)),
//   description: 'training_points'
// });

/////// loading training and validation points, adjust paths
var trainingpoints = ee.FeatureCollection('projects/ee-mepo/assets/training_points');
// print(trainingpoints.first());
// print(trainingpoints.aggregate_histogram('b1'));
// print(trainingpoints.size());
// Map.addLayer(trainingpoints,{color: 'black'},'Trainingpoints total')

/////////////// Loading validation points, prepared in QGIS ////////////////////
var validationpoints = ee.FeatureCollection('projects/ee-mepo/assets/validation_points_new');
// print(validationpoints.first());
// print(validationpoints.aggregate_histogram('b1'));
// print(validationpoints.size());
// Map.addLayer(validationpoints,{color: 'red'},'Validationpoints total')

//////////// training the classifier //////
var label = 'b1';

/////// Creating and Exporting Training- and Validationdata per year ///////////
//////////2020//////////
// Export.table.toAsset({
//   collection: ee.FeatureCollection(s2_20_all.sampleRegions({
//     collection: trainingpoints,
//     properties:[label],
//     scale: 10,
//     tileScale: 4,
//     geometries: true
//     })),
//   description: 'training_20'
// });
// Export.table.toAsset({
//   collection: ee.FeatureCollection(s2_20_all.sampleRegions({
//     collection: validationpoints,
//     properties:[label],
//     scale: 10,
//     tileScale: 4,
//     geometries: true
//     })),
//   description: 'validation_20'
// });
////////////Classification///////////////
////////////2020//////////
var training_20 = ee.FeatureCollection('projects/ee-mepo/assets/training_20');
var validation_20 = ee.FeatureCollection('projects/ee-mepo/assets/validation_20');
print(training_20.first());

// print('Training 20 je Klasse: ',training_20.aggregate_histogram('b1'));
// print('Training 20 Size: ',training_20.size());

var classifier_20 = ee.Classifier.smileRandomForest(130)
  .train(training_20,label,s2_20_all.bandNames());

///// get a dictionary with the feature importance of the classifier
var dict_featImportance = classifier_20.explain();
print('Results of trained classifier20', dict_featImportance);
///// Cast into a ee.Feature and a ee.FeatureCollection for exporting the importance as CSV
var variable_importance = ee.Feature(null, ee.Dictionary(dict_featImportance).get('importance'));
var variable_importance01 = ee.FeatureCollection(variable_importance);
///// Export the FeatureCollection as CSV
// Export.table.toDrive({
// collection: variable_importance01,
// description: 'variable_importance_subset20',
// fileFormat: 'CSV'
// });
///// Plot the importance of each band in a bar plot
var chart =
ui.Chart.feature.byProperty(variable_importance)
.setChartType('ColumnChart')
.setOptions({
title: 'Random Forest Variable Importance',
legend: {position: 'none'},
hAxis: {title: 'Bands'},
vAxis: {title: 'Importance'}
});
print(chart);

///// Classification /////
// Export.image.toAsset({
//   image: s2_20_all.classify(classifier_20).clip(ROI),
//   description: 'classification2020',
//   region: ROI,
//   scale: 10,
//   crs: 'EPSG: 3037',
//   maxPixels: 1234288260
// });
var classified_20 = ee.Image('projects/ee-mepo/assets/classification2020');
var scale = 10;
var classified_20_smooth = classified_20.focalMode();
var classified_20_smooth2 = classified_20_smooth.focalMax(3).focalMin(5).focalMax(3);
var class20_reproject = classified_20_smooth2.reproject('EPSG:3037',null,scale);
// Map.addLayer(classified_20, viz, 'Classification 2020',false);
// Map.addLayer(class20_reproject, viz, 'Classification 2020 smoothed',false);

// Export.image.toDrive({
//   image: classified_20_smooth.focalMax(3).focalMin(5).focalMax(3),
//   description: 'classification2020_smooth',
//   region: ROI,
//   scale: 10,
//   crs: 'EPSG: 3037',
//   maxPixels: 1234288260
// });

////////////////////// ACCURACY ASSESSMENT //////////////////////////////
///// Get a confusion matrix representing resubstitution accuracy. /////
var trainAccuracy_20 = classifier_20.confusionMatrix();
print('2020 Resubstitution error matrix: ', trainAccuracy_20);
print('2020 Training overall accuracy: ', trainAccuracy_20.accuracy());
/// Classify the validation data. /////
var validated_20 = validation_20.classify(classifier_20);
// Export.table.toDrive({
//   collection: validated_20,
//   description: 'validated_20'
// })
///// Get a confusion matrix representing expected accuracy. /////
var testAccuracy_20 = validated_20.errorMatrix('b1', 'classification');

print('2020 Validation error matrix: ', testAccuracy_20);
print('2020 Validation overall accuracy: ', testAccuracy_20.accuracy());
print('2020 Validation Consumers accuracy: ', testAccuracy_20.consumersAccuracy());
print('2020 Validation Producers accuracy: ', testAccuracy_20.producersAccuracy());

// // Export Confusion Matrix
// var exportAccuracy = ee.Feature(null, {matrix: testAccuracy_20.array()})
// Export.table.toDrive({
//   collection: ee.FeatureCollection(exportAccuracy),
//   description: 'ConfusionMatrix2020',
//   fileFormat: 'CSV'
// });